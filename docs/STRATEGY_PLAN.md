Trainer Area – Modular Build Plan (Phase 1)
This plan outlines the development tasks for the Trainer Area of a fitness CRM platform. The Trainer Area consists of several modules, each broken down into purpose, dependencies, and specific implementation tasks. All modules are web-first (responsive design) and prepared for future mobile app integration. The plan is structured for an AI developer agent to implement in modular fashion, focusing on code-ready tasks with minimal repetition of known architecture.
Dashboard
Purpose: Provides trainers with a quick overview of their business and clients. It displays key metrics (active clients, upcoming sessions, pending check-ins), AI-driven alerts (e.g. client progress stagnation warnings), and quick actions for common tasks. Dependencies: Requires data from other modules (Clients, Planner, Check-Ins) to aggregate counts and alerts. Uses Messaging for alerts (e.g. sending notifications) and Membership logic for any feature limits (if applicable). Frontend Components:
Dashboard Page UI: A summary page showing metric cards (e.g. Active Clients, Upcoming Sessions, Pending Check-Ins), an AI Alerts panel, and quick-action buttons.
Metrics Cards: Reusable card components displaying counts (fetched via API) for active clients, upcoming sessions/events, pending check-ins, etc.
AI Alerts Widget: Section listing smart alerts (e.g. “Client X’s weight has plateaued for 3 weeks”) with icons or highlights. Possibly include links to relevant client profiles or actions.
Quick Action Buttons: Prominent buttons (or icons) for “Create Plan”, “Send Check-In”, “Add Session” that open the relevant module’s modal or page (triggering Planner, Check-In, or Workouts/Nutrition flows).
Backend Endpoints:
GET /trainer/dashboard/metrics – Aggregate and return counts for active clients, upcoming sessions (within next X days), pending check-ins, etc.
GET /trainer/dashboard/alerts – Retrieve AI-generated alerts for the trainer (e.g. stagnation warnings). The AI logic monitors client progress (e.g. check-in metrics trends) and flags issues.
(Optional) POST /trainer/dashboard/alerts/acknowledge – Mark an alert as read or addressed (if needed for UX).
Database Schema:
No new major tables (uses existing data). Ensure relevant tables exist and have needed fields: e.g. Clients table has an active status or join date to count active clients; Sessions/Events table to query upcoming sessions; CheckIns table to find pending submissions.
Possibly an Alerts table (if alerts are stored/persisted): fields for trainer_id, client_id, type (e.g. stagnation), message, created_at, status (unread/read). Alerts might also be generated on the fly without storage, depending on AI integration.
Notes on Cross-Module Integration: The Dashboard pulls in data from various modules – it must integrate seamlessly. For example, Upcoming Sessions links into the Planner (calendar) module, Pending Check-Ins links to the Check-In System, and alerts may prompt using Messaging (e.g. sending a message to a client). Ensure the quick action buttons route to the correct module workflows. Smart AI alerts will rely on data from Check-Ins or Clients (e.g. weight logs) – consider a background job to analyze metrics and create alerts daily.
Messaging
Purpose: Enables real-time communication between trainers and their clients. This module provides a chat interface, categorises certain messages by type, and allows quick actions from conversations (e.g. scheduling a session or sending a check-in request directly from chat). Dependencies: Relies on Clients module (each chat is linked to a client or a group), and possibly uses a real-time service (WebSocket server or similar) for instant messaging. Integrates with Planner, Workouts, Nutrition, and Check-In modules for sending related content (plans, session invites, check-in forms) through the chat. Frontend Components:
Conversations List: UI list of chat threads (typically one per client). Shows client name, maybe last message preview and unread count. Allows filtering or searching clients.
Chat Window: Real-time messaging panel for a selected client. Supports scrolling message history, sending new messages, and displaying message timestamps (converted to local time).
Message Input & Actions: Text input for messages and attachments. Include quick-action buttons or menu to “Send Plan”, “Request Check-In”, or “Book Session” – clicking these can open the respective module’s modal (e.g. new workout plan modal) or insert a structured message (like a session invite card).
Message Bubbles with Categories: Differentiate system-generated or categorised messages (e.g. a Plan Update message could be styled differently or tagged). Provide visual labels or sections for categories like Plan Updates, Check-In Requests, Session Bookings for easy scanning.
Backend Endpoints:
GET /trainer/messages/threads – List of conversation threads for the trainer (clients and maybe groups). Includes last message, unread count, etc.
GET /trainer/messages/thread/{clientId} – Fetch message history with a specific client. Supports pagination.
POST /trainer/messages/thread/{clientId} – Send a new message to the client. Handles text and possibly attachments (images/files), and can include a type or category field if it’s a system message (e.g. plan_update, checkin_request).
Real-Time Channel: Establish a WebSocket or similar push channel for new messages. When either party sends a message, deliver it in real-time to the other. Implement message events (e.g. new_message) that the frontend listens for to update the chat instantly.
(Optional) POST /trainer/messages/thread/{clientId}/typing – Send “typing” indicators (not essential, but common in chat UX).
Database Schema:
Messages table: id, thread_id (or trainer_id & client_id), sender_id (trainer or client), message_text, attachment_url (nullable), type (enum: normal, plan_update, checkin_request, session_invite, etc.), timestamp. Also a read status or separate ReadReceipts table if needed (to track if the client read the message).
Threads (Conversations) table: id, trainer_id, client_id (assuming one-on-one chats). This can be implicitly derived, but a table helps list threads quickly. Could also support group chat if needed (then thread might have multiple participants, but in this context likely one trainer to one client).
Possibly extend Messages or Threads with a category for the last message category for filtering. More simply, derive categories by scanning messages.
Ensure Clients and Trainer (User) tables exist for foreign keys.
Notes on Cross-Module Integration: The Messaging module interacts with several others. For example, when a trainer creates a new workout plan for a client, the Workouts module can post a system message (“New workout plan created”) into the chat, categorised as a Plan Update. Similarly, scheduling a session via Planner could send an invite message (with details and maybe an Accept/Decline button for the client), categorised as Session Booking. A manual Check-In Request can be initiated in chat, triggering the Check-In System to generate a request and post a message. The messaging system should handle these different types gracefully – perhaps by rendering special UI elements (like a card or link) for certain message types. Real-time capability ensures that if a client sends a chat (from the client app, in a later phase), the trainer sees it immediately.
Clients
Purpose: Manages the trainer’s client information and interactions. Includes a list of all clients, filtering/tagging for organisation, inviting new clients, and detailed client profile views (including timeline of activities, metrics, and personal details). Dependencies: Central to most modules – interacts with Messaging, Planner, Nutrition/Workouts, Check-In, and Team Management (if clients can be delegated). Depends on Membership tier for client limits and on Trainer Profile for branding (e.g. invites). Integration with Gym context if needed (e.g. linking a client to a gym membership in future phases). Frontend Components:
Client List Page: Displays all clients the trainer can access. Features search bar, filters (e.g. by tag, active/inactive status), and tags next to names (for categorisation like “premium”, “rehab”, etc.). Each list item shows basic info (name, last session date, upcoming events, alerts if any).
Invite Client Modal/Flow: UI to invite a new client. Options: invite via email (enter email to send a sign-up link) or generate invite link (copyable URL). The modal may allow entering basic info (name, email, tags) and selecting whether to send an invite or just create a profile. After invitation, show confirmation and allow re-sending or copying the link.
Manual Client Creation Form: An alternative path to directly add a client profile without sending an invite (for example, to track someone before they use the app). Fields for name, email/phone (optional), initial metrics or notes. If an email is provided, offer an option to send an invite later or convert the profile to a registered account when the client accepts.
Client Profile View/Modal: A detailed profile for each client. This can be a modal overlay or separate page. It shows personal details (age, height, medical info, goals, allergies, experience level, etc.), current metrics, and possibly progress graphs. Also includes sub-sections or tabs: Timeline (chronological feed of that client’s activities: sessions completed, plans assigned, check-ins submitted, messages, etc.), Plans (list of assigned workout/nutrition plans), Check-Ins (history of check-in submissions), and Documents (if clients upload or share any, though not mentioned explicitly for clients). Provide edit options for trainer to update client info or add notes.
Recurrent Check-In Scheduler UI: Within the client profile (or as part of client creation), an interface to set up automated check-ins. The trainer can configure frequency (e.g. weekly, monthly on a given day) and select which fields to include (e.g. weight, mood, energy level, custom questions) and whether progress photos are required. This might be a form with multi-select options and a frequency dropdown.
Timeline Feed Component: Displays a scrollable list of timeline entries (e.g. “Jun 24: Check-In completed – Weight: 80kg, Mood: Good”, “Jun 20: Workout Plan updated”, “Jun 18: Session with Trainer A”). Each entry notes the date and a brief description. This component is fed by data from multiple modules.
Backend Endpoints:
GET /trainer/clients – Retrieve the list of clients for the trainer (respecting any filters or search queries). Possibly supports query params for filter (tag, status).
POST /trainer/clients – Create a new client profile. Supports both invite flow and manual creation: if an email is provided and invite flag is true, trigger sending an invite; otherwise create a profile as inactive/unregistered client.
POST /trainer/clients/invite – Send an invite to an email (could be combined with above). Generates a unique invite token, emails the invite link to the client.
GET /trainer/clients/invite/{token} – (This might be handled on a public endpoint in client app, but mention for completeness) Validate invite token and provide initial signup details (this would be used by the client-facing side when they accept invite).
PUT /trainer/clients/{clientId} – Update client’s profile info (personal details or tags).
GET /trainer/clients/{clientId} – Get full details for one client (including their metrics, last activities, etc. to populate profile modal).
GET /trainer/clients/{clientId}/timeline – Fetch timeline events for that client (aggregated from sessions, check-ins, plans, etc.).
POST /trainer/clients/{clientId}/schedule-checkin – Set up or update a recurring check-in schedule for that client. Include payload of frequency (e.g. every 7 days), fields (list of metrics/questions to track), and photo requirement (boolean). This would create the schedule and possibly immediately create the first pending check-in entry or set next due date.
GET /trainer/clients/{clientId}/checkins – List past check-in submissions (for profile view).
POST /trainer/clients/{clientId}/checkins – (This is actually a client-side action when a client submits a check-in; but trainer could add a manual entry if needed). In trainer area, perhaps only needed if trainer logs something on behalf of client. Otherwise, this would be handled on client side in a later phase.
DELETE /trainer/clients/{clientId} – (If needed) Remove a client or mark as inactive. Possibly only allowed if the client is not active or to revoke access.
Database Schema:
Clients table (if not existing already): Fields such as id, trainer_id (owner), name, email, phone, tags (maybe a separate tags table), status (active/invited/inactive), created_at, invited_at (if applicable), invite_token (nullable), ... plus profile fields (age, height, etc., or a separate Profile table). If the platform has a central Users table, clients who register will have a user account reference (user_id). Unregistered clients might exist only in Clients table without a login.
ClientMetrics table: to store custom metric data (e.g. initial metrics or ongoing personal data like goal weight, allergies, etc.). Alternatively, these can be columns in Clients table, but a separate table allows extensibility for various metrics.
CheckInSchedule table: id, client_id, frequency (e.g. interval in days or cron pattern), fields (perhaps JSON or a normalized related table listing metric fields to collect), photo_required (bool), next_date, last_sent_date. This defines the recurring check-in settings per client.
CheckIns table: Records of actual check-in submissions. Fields: id, client_id, trainer_id, scheduled_date (when it was supposed to happen), submitted_at, data (JSON or related table for each field value), photos (maybe links to uploaded images if any). Each check-in entry ties back to a schedule or at least to a client.
TimelineEvents table: (optional) A unified log of events per client. Could store events like date, client_id, type (e.g. checkin, plan_update, session, note), reference_id (ID of related object like session_id or plan_id), description. This makes it easy to fetch a timeline. Alternatively, the timeline can be generated on the fly by querying other tables (sessions, checkins, etc.).
Notes on Cross-Module Integration: The Clients module is interconnected with nearly everything. Creating or inviting a client might trigger a welcome message in Messaging or appear on the Dashboard as a new client count. The Planner will use the client list to schedule sessions or events with specific clients (by referencing client IDs). Nutrition and Workouts modules attach plans to clients, which should reflect in the client’s profile (e.g. in their Plans section and timeline). The Check-In System uses the scheduler configured per client to prompt them (client-side) and logs their responses – those responses should update the client’s metrics and timeline. Team delegation (from Team Management module) can affect this module: if a client is delegated to another trainer in the team, that trainer should see them in their client list (likely with an indicator or filter for delegated vs direct clients). Membership tier from Membership Logic may enforce a limit on how many clients can be added (e.g. Free tier maximum). The invite flow needs to integrate with user authentication (creating a user account when the invite is accepted in a later phase). Ensure that when a client accepts an invite and registers, their profile in this module links up to the new user account smoothly (perhaps update Clients.user_id at that time).
Planner (Calendar)
Purpose: Provides a scheduling interface for sessions and events. Trainers can manage their calendar – adding one-on-one sessions or group events, inviting clients, and handling attendance and payments. It supports drag-and-drop scheduling and ensures clients can accept or decline invites. It also handles paid sessions with payment processing. Dependencies: Relies on Clients (to invite clients to sessions/events), Messaging/Notifications (to send invites or updates), Membership (possibly to limit number of events or calendar features on free tier), and Timezone Support (for correct time displays). Integrates with a payment gateway for session/event fees and with Team Management if sessions can be assigned to team members. Frontend Components:
Calendar UI (Planner Page): A drag-and-drop calendar interface (weekly or daily view). Shows scheduled sessions/events as blocks. Trainer can click or drag to create a new session/event at a time slot. Supports switching views (day/week) and is responsive for mobile (perhaps list or agenda view on small screens).
Session/Event Card (Calendar Entry): Visual representation of a session on the calendar, showing title (e.g. client name or event name), time, and maybe an icon indicating type (personal session or group event). If multi-client event, might show an attendee count (e.g. “Group Class (3/5 attending)”). If paid session, maybe a £ or $ symbol indicator.
Add/Edit Session Modal: Form to create or edit a session. Fields: title or type (Session vs Event), date & time (with timezone awareness), duration, client selection (one or multiple), location (if needed), fee (for paid sessions or events), and any notes. For events: capacity limit (optional), and perhaps a checkbox for “require payment on RSVP”. If multiple clients can join, treat it as an Event. The form should allow selecting multiple clients (dropdown with multi-select) or even a “invite all from a group/tag”. For one-on-one sessions, a single client select.
Event Details View: For group events, a summary view listing all invited clients and their RSVP status (accepted/declined/pending) and payment status. The trainer can manually mark attendance or remove a client from the event here. Also allow editing event details or cancelling the event.
Notification UI: If a client accepts or declines an invite (in a later client-phase, but pre-emptively), the trainer should get a notification or the calendar entry updates (e.g. the event card could update attendance count and maybe highlight if someone declined). This could be part of the Alerts or the event detail.
Backend Endpoints:
GET /trainer/planner/events – Fetch trainer’s events and sessions for a given date range (to populate the calendar). Could combine both one-on-one sessions and group events as “events” in the response, with fields indicating type and attendees.
POST /trainer/planner/events – Create a new event or session. Accepts data: date/time, duration, list of client IDs (one for session, multiple for event), fee amount (if any), capacity (if event), title or description, and possibly a trainer_id if assigning to another trainer (team scenario). If fee is set and payment on RSVP is required, generate payment instructions (e.g. create a pending payment record). Should also trigger sending invites/notifications to the clients invited (likely via messaging or email).
PUT /trainer/planner/events/{eventId} – Update an event/session (time change, details update). If time is changed, notify clients. If capacity or fee is changed, handle accordingly (could be complex if payments already made; possibly disallow some changes after invites sent).
DELETE /trainer/planner/events/{eventId} – Cancel an event/session. This should trigger notifications to invited clients about cancellation. If the event was paid, initiate automatic refunds for all who paid.
POST /trainer/planner/events/{eventId}/invite – (Optional separate endpoint) Invite additional clients to an existing event, or re-send invites. Could also be done via update, but explicitly inviting might be clearer.
POST /trainer/planner/events/{eventId}/remove-client – Remove a specific client from an event. This should update their status (and issue a refund if they had paid).
POST /trainer/planner/events/{eventId}/respond – (Will be used by clients in their app to accept/decline invites, but include for integration) Accept or reject an invite. If accepted and a fee exists, this should trigger the payment process. For Phase 1, the trainer might manually record responses or see them; actual client response handling might come in Phase 2.
GET /trainer/planner/events/{eventId}/attendees – Get list of attendees with their status and payment info (for event detail view).
GET /trainer/planner/availability – (If needed for client self-booking in future) Return trainer’s free slots, etc. (Not explicitly in scope now, but might be planned later).
Database Schema:
Events (Sessions) Table: A table for all calendar entries (both one-on-one sessions and group events). Fields: id, trainer_id, title (or type: session/event), start_datetime (UTC):contentReference[oaicite:0]{index=0}, duration, location (if needed), fee (nullable if free), capacity (nullable or 1 for sessions), is_paid_event (bool, or derive from fee > 0), status (active/cancelled), created_at. Storing times in UTC and converting to user local time on display is recommended
medium.com
. If supporting recurring events in future, additional fields like recurrence pattern could be added (not in current scope).
EventAttendees (Invitations) Table: Records the clients invited or booked for events. Fields: id, event_id (FK to Events), client_id, status (invited/pending, accepted, declined, cancelled), payment_status (pending, paid, refunded), payment_transaction_id (for tracking payments if any), invited_at, responded_at. This table allows tracking RSVP and payments per client for group events or even one-on-one sessions. For one-on-one sessions, there would typically be one entry here linking that single client. Using a join table like this is a scalable approach to handle variable number of attendees and their responses
dba.stackexchange.com
.
Payments (or integrate in above): If a separate Payments table exists, store each transaction (id, event_id or client_event_id, amount, status, transaction_ref, timestamp). This is used to manage charging clients and issuing refunds.
TrainerAvailability (optional/future): could store default working hours or unavailable times, if needed for scheduling logic (not mentioned explicitly, so optional).
Notes on Cross-Module Integration: The Planner is a central hub that connects with messaging, payments, and client management. When a session/event is created, the system should send out invites – possibly via the Messaging module (e.g. an automated chat message or push notification). Accept/Reject by clients (to be built in client app) will feed back into this module: accepted events might appear confirmed on the trainer’s calendar, while declines might either remove the client or mark them as not attending. Payment integration is crucial: when a client accepts an event with a fee, redirect them to the payment gateway (in client app) or charge via saved card – after successful payment, mark payment_status as paid and confirm their spot. On trainer-side cancellation, use the stored payment_transaction_id to issue refunds automatically. The Team Management integration: if a trainer has a team, the event creation form might allow choosing an instructor (any team member) for a session. In such cases, the trainer_id in the Events table might be the team member who will conduct it, and perhaps an owner_id or similar stays as the one who scheduled (team owner). Ensure timezone support – if trainer and client in different zones, invites and calendar views for each should localise times appropriately (store in UTC, convert on frontend
medium.com
). Also consider membership limits: possibly limit number of active events for free tier or restrict group size features for free (not specified, but something to keep in mind).
Nutrition
Purpose: Allows trainers to create and manage diet plans for clients. Features an AI-generated meal plan utility and manual editing of plans. Trainers can maintain a library of nutrition plans, assign them to clients, and customise per client. Dependencies: Uses an AI service for plan generation (based on inputs). Relies on Clients (each plan is associated with a client or is a template). Possibly interacts with Messaging to send a plan to a client, and with Membership Logic for AI usage limits (credits/cooldowns on generation). Shares similarities with Workouts (parallel structure for workout plans). Frontend Components:
Nutrition Plans List: Page or section showing a list of meal plans. Could be filtered by client or global templates. For a selected client, show their current and past plans. Each entry shows plan name, date created, and an option to view or edit.
Plan Detail/Edit UI: Viewing a specific nutrition plan in detail. Likely a structured list of meals per day, with nutritional info. Provide an edit mode where the trainer can modify meals, ingredients, or portions manually.
AI Plan Generator Modal: A pop-up form where trainer inputs criteria to generate a new meal plan. Fields: client (if not already selected), goal (e.g. weight loss, muscle gain), daily calorie target, dietary preferences (e.g. vegetarian, keto), allergy restrictions, number of meals per day. Buttons for “Generate Full Plan” and possibly “Regenerate Meal” (if editing an existing plan, allow regenerating one meal). This modal triggers an AI API call and displays a loading state until the plan is returned.
AI Generation Feedback UI: Once generated, show the proposed plan (meals with recipes or food items). Allow trainer to accept it, or regenerate specific parts (e.g. a particular meal if the user clicks a regenerate button next to it). Also display any credit usage information or cooldown timer if applicable (e.g. “AI generation available in 1 hour” if limit reached).
Duplicate & Assign Feature: In the plan list or detail, an option to “Duplicate Plan” which opens a dialog to select another client to assign the copied plan to. This allows reusing a plan structure for a different client (especially useful if the plan is generic enough).
Backend Endpoints:
GET /trainer/nutrition-plans?client={clientId} – Fetch nutrition plans. If clientId is provided, return plans for that client. Otherwise, could return trainer’s templates or all plans.
GET /trainer/nutrition-plans/{planId} – Get details of a specific nutrition plan (meals, ingredients, etc.).
POST /trainer/nutrition-plans – Create a new nutrition plan. The request could include a base plan data if manually created, or be empty if using AI (in which case the backend might call the AI service). Alternatively, for AI generation, use a separate endpoint as below.
POST /trainer/nutrition-plans/generate – Use AI to generate a plan. Accepts parameters: goal, calories, preferences, allergies, meals_per_day, etc., plus a clientId (optional if generating a general template). This will call an internal AI component or external API to get a suggested plan (list of meals with details). On success, save the plan to the database (with status draft perhaps) and return it. Enforce credit/cooldown: check the trainer’s remaining AI credits or cooldown period before proceeding. If over limit, respond with an error or message. Deduct a credit upon generation and start a cooldown timer if needed (this logic likely interacts with Membership module).
PUT /trainer/nutrition-plans/{planId} – Update an existing plan. Used for manual edits (changing meals or ingredients) or for duplicating (assigning to another client by creating a new plan record).
POST /trainer/nutrition-plans/{planId}/duplicate – (Alternatively, a convenient endpoint) Duplicate the given plan to a new one, possibly with a different clientId. Could also be done client-side by GET then POST, but an endpoint can simplify.
DELETE /trainer/nutrition-plans/{planId} – Delete or archive a plan (if needed). Trainers might remove old plans or templates.
Database Schema:
NutritionPlans table: id, trainer_id, client_id (nullable if template), title (e.g. "Cutting Plan June"), created_at, calories_target, meals_per_day, goal, dietary_pref (text or enum), ....
Meals table: Each plan has many meals. Fields: id, plan_id, name (e.g. Breakfast 1), sequence (order in day), calories, etc.. Possibly macros breakdown if provided.
MealItems table (optional): If each meal has multiple components (recipes or food items), store them here with meal_id, description or food_item, quantity, etc. Alternatively, store a meal’s content as a text blob or JSON if detailed structure isn’t needed.
AIUsageLog/Credits: If implementing credit and cooldown, have a table to track usage: e.g. AIUsage with trainer_id, feature ("nutrition_plan"), timestamp. Or simply fields in Trainer or Membership record: e.g. ai_credits_used (this period) and a timestamp of last use to enforce cooldown. Free tier might have monthly_ai_credits that reset, etc.
Ensure to link any generated content with the ability to edit. If AI returns a big structured JSON for the plan, it should be parsed into the above tables or stored in a JSON field and then broken down for editing.
Notes on Cross-Module Integration: The Nutrition module’s primary integration is with Clients – each plan is associated with a client. When a plan is generated or updated, consider adding a Timeline entry (e.g. “Nutrition plan created”) and possibly sending a message via Messaging (“Your trainer has added a new meal plan”) for the client. The Messaging quick action could trigger the AI generator for nutrition (if a trainer is chatting with a client and wants to quickly send a diet plan, they might click a “Generate Meal Plan” action that opens the AI modal pre-filled with that client). Membership tier integration: enforce limits on AI usage (free vs pro). Also possibly limit how many active plans a free trainer can have, though not explicitly stated. The Workouts module will be very similar in structure to Nutrition – likely share some components or patterns (maybe a common AI service with different prompt parameters). If the trainer is linked to a Gym, and the gym has certain food options (unlikely, but for Workouts the gym equipment matters, see below). Ensure that duplicating a plan to another client only copies the content but uses the new client_id. Also, if a client is reassigned to another trainer (via Team), clarify if plans transfer or remain with original trainer – likely remain with original trainer’s library unless explicitly transferred.
Workouts
Purpose: Manages workout plans for clients, parallel to the Nutrition module. Trainers can create workout routines, use AI to generate personalised workout plans, and edit or reuse plans. This includes incorporating gym equipment constraints and handling different training splits. Dependencies: Similar to Nutrition: uses AI service for generation, Clients for linking plans, Membership for AI limits, Gym data for equipment if needed, and possibly shares components with Nutrition for plan management UI. Integrates with Messaging for sharing plans or quick actions. Frontend Components:
Workout Plans List: List of workout programs, filtered by client or templates. Shows each plan’s name (e.g. “4-Week Strength Program”), creation date, and status.
Plan Detail/Edit UI: Shows the workout plan in detail, likely structured by days or sessions. For example, a weekly schedule with exercises for each day (if it’s a multi-day split). Provide editing capabilities: modify exercises, sets, reps, etc.
AI Workout Generator Modal: Similar to nutrition’s modal but for workouts. Input fields: client (or target client), goal (strength, fat loss, endurance, etc.), preferred split type (e.g. full-body, upper/lower, push-pull-legs, etc.), sessions per week, gym selection (if the trainer wants to tailor to a specific gym’s equipment; perhaps a dropdown of gyms the trainer is associated with or “Any”), and injuries or limitations (text field or checklist). On submission, calls AI to generate a structured workout plan. The plan likely includes a breakdown of exercises per session for the week.
Generation Results & Editing: Display the generated workout plan. Perhaps list Week 1…Week N (if multi-week) or just one week that repeats. Under each day/session, list exercises with sets/reps. Allow trainer to regenerate a single exercise slot if it seems unsuitable (e.g. a “regenerate” button next to a particular exercise suggestion). The trainer can also manually edit any part (change exercise or adjust sets).
Duplicate & Assign: Like nutrition, an option to duplicate a plan to another client (useful if two clients follow the same program structure).
Backend Endpoints:
GET /trainer/workout-plans?client={id} – List workout plans, optionally filtered by client.
GET /trainer/workout-plans/{planId} – Get full details of a workout plan (exercises, schedule).
POST /trainer/workout-plans – Create a new workout plan (manually). Could be rarely used if AI is primary method, but allow manual plan creation/edit saving.
POST /trainer/workout-plans/generate – Generate a workout plan via AI. Accepts inputs: goal, split_type, sessions_per_week, gym_id (optional), injuries (text), client_id (optional). The backend calls AI with these parameters and returns a plan structure. Enforce credit/cooldown similar to nutrition. If a specific gym_id is provided, the AI logic should factor in available equipment at that gym (requires knowing the gym’s equipment list – likely the gym has a profile with equipment details, which the AI can use to tailor exercises).
PUT /trainer/workout-plans/{planId} – Update a workout plan (after edits or to assign to a client).
POST /trainer/workout-plans/{planId}/duplicate – Duplicate the plan to a new one (with a different client or template copy).
DELETE /trainer/workout-plans/{planId} – Delete/archive a workout plan.
Database Schema:
WorkoutPlans table: similar structure to NutritionPlans. Fields: id, trainer_id, client_id, title, created_at, goal, sessions_per_week, split_type, gym_id (nullable), .... Possibly a field for duration (like 4 weeks, or just infer from entries).
WorkoutSessions (Plan Days) table: If structuring a plan by sessions or days, each plan could have multiple session definitions. Fields: id, plan_id, day_index or name (e.g. Day 1, Day 2...), focus (e.g. Chest/Back if split), ....
Exercises table: Individual exercises in a plan session. Fields: id, plan_id (or session_id if above separation), name (e.g. Bench Press), sets, reps, rest, equipment, order, notes. If not splitting by a separate session table, then at least include a day field to group exercises by day.
Possibly an Equipment reference: If integrating gym equipment, ensure we have a GymEquipment table associated with gyms (or a field in the exercise indicating required equipment and filter out if not available at chosen gym). Gym integration might be: the trainer links a gym that has certain equipment list; the AI generator should prefer or only include those exercises. That implies we need a way to get a list of equipment for a gym (this might be pre-stored or input by gym owners). For now, assume gym data available via gym module.
AIUsage/Credits: shared with Nutrition – track usage of AI for workout generation as well (could be a common system).
Notes on Cross-Module Integration: Workout plans link to Clients and likely appear on the client’s timeline (“Workout plan updated/assigned”). As with Nutrition, sending a new plan could trigger a chat message via Messaging (“New workout plan available”). The AI generator usage counts toward the trainer’s membership AI credits – ensure both Nutrition and Workouts consumption draw from the same credit pool (if that’s the design) or separate pools as defined. The Gym integration: if the trainer specifies a gym for the plan, use the equipment from that gym. That likely requires an API to get gym equipment data (GET /gyms/{gymId}/equipment) from the Gym module (phase 3 perhaps). In absence of gym selection, assume generic bodyweight or common equipment exercises. Team integration: if a trainer is part of a team, possibly sharing plans or templates might be desirable (not explicitly stated, but could be a future enhancement). For now, each trainer manages their own plans. Ensure the UI and storage can handle regenerating individual exercises – likely just call the AI with a request to regenerate that one exercise (maybe provide context of the rest of the plan for consistency). This could be a smaller endpoint or reuse the generate endpoint with a flag indicating a partial regeneration (or handle on frontend by calling AI with similar params focusing only on that muscle group/day). As with nutrition, the plan editor should allow complete manual override.
Check-In System
Purpose: Allows trainers to regularly collect progress data from clients through check-ins. The trainer can customise each client’s check-in schedule and form fields, and the system automates reminders. Clients’ check-in submissions (metrics and photos) are logged for the trainer to review and track progress over time. Dependencies: Tied closely to Clients (each client has their own check-in settings and records). Uses Messaging/Notifications for sending reminders or links to check-in forms. Data from check-ins feeds into Dashboard (pending check-ins count) and Timeline (progress updates). Possibly interacts with AI Alerts (e.g. stagnation detection uses check-in data). Also consider Timezone Support (send reminders at appropriate local time) and Membership (free vs pro might differ in number of automated features or something, though not stated). Frontend Components:
Check-In Schedule UI: Likely part of the client profile or a settings panel for each client. Allows trainer to set how often the client should check in. Options might include weekly, fortnightly, monthly, or a specific custom interval. Also allow selecting which fields to include: e.g. weight, body measurements, mood, energy level, custom question text, etc., plus a toggle for requiring progress photos.
Check-In Form (Trainer View): The trainer might not fill this form (the client does), but the trainer should be able to preview it or manually trigger one. Perhaps a trainer can also log a check-in on behalf of a client if needed (e.g. if collecting data in person). So a form interface for check-in data input might exist for trainer usage too.
Pending Check-Ins List: The dashboard or client list might highlight clients who have a check-in due or overdue. Could implement a small section “Pending Check-Ins” listing clients with due dates. Trainer can click to view details or send a reminder.
Check-In Review View: For each submitted check-in, a view to see the data and photos. This might be accessible via the timeline or a dedicated tab in client profile (e.g. “Check-Ins”). It should show historical entries, possibly with the ability to compare changes (e.g. last weight vs current weight, etc.). Graphs could be a future enhancement to plot progress over time.
Photo Gallery/Viewer: If photos are included, provide a way to view them side by side (e.g. front/side progress pictures, possibly comparing current vs previous).
Backend Endpoints:
POST /trainer/checkins/schedule – Create or update a check-in schedule for a client. (As noted under Clients: could also be POST /trainer/clients/{id}/schedule-checkin instead to keep it contextual.) This stores the frequency and fields. Potential payload: clientId, frequency (in days or cron expression or named period), fields (array of field identifiers or names for standard ones, plus any custom questions text), photo_required (bool), start_date (when to begin scheduling, e.g. immediately or a specific day).
GET /trainer/checkins/pending – Get a list of pending or upcoming check-ins for the trainer’s clients. Used for the dashboard widget. Could return items like {client_id, client_name, due_date}. This is derived from each client’s schedule and last check-in.
POST /trainer/checkins/{clientId}/reminder – Trigger sending a reminder to a client for a pending check-in. This might send an email or message notification. The system will also auto-send these, but this allows manual triggering.
GET /trainer/checkins/{clientId} – Fetch all check-in records for a client, or perhaps support query param for a date range. Returns the submitted data (weight, answers, etc.) and links to photos if any.
GET /trainer/checkins/{clientId}/latest – Quick endpoint to get the latest check-in (for display on profile).
(Client-side endpoint, for context later: POST /client/checkins for clients to submit their check-in form responses. Phase 2 likely.)
Automated Reminder Logic: Not an endpoint but a scheduled job – the system should regularly (daily, or at specific times) check which clients have check-ins due (according to schedule and last submission) and send out notifications. This could be implemented as a cron on the server that uses the schedule data.
Database Schema:
CheckInSchedule table: (As mentioned earlier) defines the recurrence for each client. Fields: id, client_id, frequency_type (enum: weekly, monthly, etc. or numeric interval), frequency_value (e.g. every 2 weeks), day_of_week/month (if applicable), next_date, fields (could be a JSON of field keys or a separate relation table linking to **CheckInField** definitions), photo_required (bool). Alternatively, store a cron-like string or ISO8601 interval. Also store last_sent or last_completed to help compute next due.
CheckInField (Template) table: Predefined field options (e.g. Weight, Mood, etc.) if needed, or simply hardcode standard ones and allow custom text. If allowing custom, a table for custom questions per client might be needed. Simpler: store in schedule as JSON with labels.
CheckIns table: Records of each check-in entry. Fields: id, client_id, trainer_id, scheduled_date (when it was supposed to be done), submitted_at, data (JSON or separate table if structured). If structured, perhaps a CheckInResponses table with one row per field answer: id, checkin_id, field_label, value for flexibility. Photos: possibly a CheckInPhotos table: id, checkin_id, image_url (or path) for storing multiple images.
Notifications (if a table for pending notifications is used) or simply rely on sending and timeline. But could log when reminders were sent, either in CheckInSchedule or a separate log.
Notes on Cross-Module Integration: The Check-In system feeds data to other parts of the platform. The Dashboard uses it to display pending check-ins count and possibly generate alerts (if a check-in is missed or if weight/mood stagnates or drops, the AI Alerts on Dashboard can flag it). The Clients timeline should include entries for check-ins (both completed and possibly a note if one is missed). Messaging/Notifications: reminders to clients can be sent as chat messages or push/email – since we have a messaging system, we might send a system message like “It’s time for your weekly check-in, please submit your updates.” Alternatively, an email if the client prefers. For Phase 1, likely just schedule the logic; actual client submission interface will be Phase 2, but we can still prepare the data structures. Ensure timezone is considered: a “Monday 9am check-in” should be based on either trainer’s or client’s timezone as appropriate (likely the client’s local time for their convenience). So the scheduling logic might use the client’s timezone (which implies each client profile should store their timezone offset or region). Also, integration with Export to PDF: check-in data will be a primary source for progress metrics that get exported.
Trainer Profile & Docs
Purpose: Enables the trainer to manage their personal profile and professional documents. The trainer can upload certifications, insurance papers, qualifications, etc., and control their visibility. The system will notify the trainer when important documents are about to expire. Dependencies: Connects with Gym and Client views in later phases (since visibility settings imply sharing with gyms or clients). Uses possibly a File Storage service for documents. Relies on Notifications for expiry alerts. Membership tier might influence storage limits (not stated, but possible). Frontend Components:
Trainer Profile Page: Shows the trainer’s personal details (name, bio, contact info, profile picture, maybe specialty). Allows editing these details. Possibly includes setting a default timezone for the trainer (used for scheduling).
Documents Upload UI: Section on the profile page for managing documents. For each category (e.g. “Certification”, “Insurance”, “Qualification”), the trainer can upload a file (PDF/Image) and enter details like name/description and expiration date. Each document entry in the UI should have a visibility toggle (e.g. icons or checkboxes for “Visible to Clients” and “Visible to Gyms”). Also allow deletion or replacement of documents.
Document List: After uploading, list out all documents with their status: show name, possibly the expiry date, and who it’s visible to. Highlight or flag documents that are expired or nearing expiry (e.g. red text if expired, or a warning icon if expiring soon).
Notifications/Banners: If a document is expiring within X days, show an alert (maybe on Dashboard or profile page) like “Your First Aid Certification expires in 5 days – please renew it.”
Backend Endpoints:
GET /trainer/profile – Retrieve trainer’s profile info (name, email, bio, etc.) and list of documents. Possibly also returns subscription status (tier, for membership page, though that might be separate module).
PUT /trainer/profile – Update profile details (name, bio, contact, timezone, etc.).
POST /trainer/profile/photo – Upload or update profile picture (if allowed, though not explicitly mentioned, likely yes as part of profile).
POST /trainer/profile/documents – Upload a new document. Accepts file (multipart) plus metadata: doc_type (enumeration or label), name/description, expiry_date (optional), and visibility flags (booleans for client_visible, gym_visible). This will save file to storage and create a DB record.
PUT /trainer/profile/documents/{docId} – Update document metadata. E.g. change visibility or expiry date, or replace the file (could also allow file replacement via this or require a delete and re-add).
DELETE /trainer/profile/documents/{docId} – Delete a document. Remove the file from storage (or mark for deletion) and remove record.
Notifications/Alerts: A background process to check document expiry: perhaps a daily job that finds docs expiring in X days and either sends an email or creates an alert (which the Dashboard can show). Could also use an endpoint like GET /trainer/profile/documents/expiring to fetch those for client-side alert display, but pushing a notification is better.
Database Schema:
Trainers table: (If a separate entity from generic Users) Fields for profile info: id, name, email, bio, phone, timezone, profile_photo_url, .... Possibly fields for membership tier and subscription status might also live here or in a related table.
Documents table: id, trainer_id, type (string or enum: "Certification", "Insurance", etc.), name (or title), file_url (or storage reference), expiry_date (nullable), visible_to_clients (bool), visible_to_gyms (bool), uploaded_at. If needing to restrict access, these visibility flags will be used when clients or gym admins view the trainer’s profile (Phase 2/3).
Possibly a DocumentType reference table if we want to pre-define categories, though free text is flexible.
Notification or Alerts: This could reuse the Alerts table mentioned for Dashboard, or a Notification system. For example, an Alert entry could be created like type="doc_expiry", message="Your insurance is expiring on X". Or simply rely on sending an email to trainer. Storing it allows showing in Dashboard alerts.
Notes on Cross-Module Integration: Trainer profile info (name, profile pic, bio) might be visible to clients (e.g. in the client’s app when they view their trainer’s profile, they see these details). Documents with visibility to clients might be accessible on the client side – for example, a client could see a trainer’s certification if marked visible. Similarly, if the platform involves gym owners, a trainer might share their documents with a gym (perhaps when joining a gym’s roster, the gym can verify certifications). In Phase 1, these docs are just stored; sharing will come later, but we should implement the flags now. The Team Management might not directly use these docs, but if a trainer is part of a team or gym, their profile docs might be relevant (e.g. gym could require certain certs – outside our scope for now). Expiry alerts integration: these alerts could surface on the Dashboard’s AI alerts or a notifications section. Membership integration: Possibly the Free tier might limit the number of documents or storage size (not stated, but could be a consideration). Ensure file uploads are handled securely and possibly integrate with an external storage service (AWS S3 or similar), though the AI agent will handle implementation details.
Team Management
Purpose: Allows a trainer to create a team of trainers and collaborate. A team (like a mini-organisation) can have multiple trainers working together. The primary trainer (team owner) can invite others, assign clients or sessions to team members, and set commission rates for revenue sharing. This module facilitates multi-trainer businesses and delegation of work. Dependencies: Relies on Trainer (User) accounts (inviting other trainers), Clients and Planner (for delegation), and possibly Membership (team features might be premium-only). Integrates with Messaging if team members need to be notified, and perhaps with a Payments/Commission system if tracking earnings (though full financial tracking might be out of scope initially, commission could be just informational). Frontend Components:
Team Dashboard/Page: Visible to a trainer who is a team owner or member. If not in a team, a prompt to create a team or accept invite. If owner, the page shows team name (perhaps the owner’s business name), a list of team members and their roles/permissions, and team-wide stats (like total clients, sessions conducted by team, etc.). If a member (not owner), show team info and members list, but with limited controls.
Invite Team Member Modal: Owner can invite a trainer by email. Similar to client invite but sends an invite link for trainers. Fields: name (optional) and email of the trainer to invite, plus an assignment of role/permissions (e.g. can they invite others? can they manage plans? etc.) and initial commission settings. On submit, an invite email is sent with a link for the new trainer to sign up or join the team.
Member List & Permissions UI: Table or list of team members with columns: Name, Role (e.g. Assistant Trainer, Manager), Permissions summary (maybe icons for what they can do), Commission rate, and actions (edit, remove). The owner can click to edit a member’s permissions or remove them from team.
Client/Session Delegation UI: Within Clients and Planner modules, integrate a way to delegate. For example, on a client profile, if part of a team, show an option “Assigned Trainer” with a dropdown of team members (default is the owner themselves). The owner can reassign a client to another trainer on their team. Similarly, when creating a session/event in the Planner, provide a field “Trainer/Instructor” if the current user has a team – default to self, but can pick a team member to lead that session.
Commission Settings UI: Possibly a section or modal where the team owner sets global commission rules or per-trainer commission. For example, they might set “Trainer B gets 50% for sessions with their clients” or define commission per client referral, etc. Given complexity, we might keep it simple: a flat percentage per secondary trainer, or even per client basis (maybe when assigning a client, the owner sets commission for that client’s revenue). UI could be as simple as an input field on the member edit modal: “Commission % for work they perform”.
Team Switcher (if applicable): If a trainer could belong to multiple teams or also operate solo, they might need to switch context. But likely a trainer is either solo or in one team, so we can ignore context switching for now.
Backend Endpoints:
POST /trainer/team – Create a new team. Only available if the trainer is not already in a team (and perhaps if their membership allows). This will create a team entry with the trainer as owner. Accepts a team name or it could default to “<Trainer Name>’s Team”.
GET /trainer/team – Get team details (for the current trainer). Includes team info, list of members with their roles, permissions, and possibly stats (count of clients, etc.). If the trainer is not in a team, this could return a 404 or empty indicating no team (UI will prompt to create or join).
POST /trainer/team/invite – Invite another trainer to the team. Payload: email, role/permissions, commission rate. This generates an invite token and emails the link.
POST /trainer/team/invite/{token}/accept – (Likely handled in a public endpoint when the invited trainer uses the link to sign up or join; not directly used by trainer, but the system will need to accept and add the user to the team. We note it for completeness.)
PUT /trainer/team/members/{memberId} – Update a team member’s info. Allows changing role, permissions, or commission for that member. Only owner (or a manager with permission) can do this.
DELETE /trainer/team/members/{memberId} – Remove a member from the team. If the member is the owner, likely not allowed (owner would have to delete team or transfer ownership). For other members, remove their association. Possibly reassign any of their clients back to owner or to someone else – that process should be handled (either automatically or require manual reassignment before removal).
POST /trainer/team/transfer-ownership – (Optional) If allowing owner to give ownership to another member, an endpoint for that. Not explicitly mentioned, might skip.
Delegation Endpoints:
PUT /trainer/clients/{clientId}/assign-trainer – Assign a client to a different trainer within the team. Payload: new_trainer_id. This updates the client’s trainer_id to the new person, but also likely keeps a record that the team still “owns” the client (maybe the team owner remains an overseer). We should ensure the client is marked as part of a team context so if the secondary trainer leaves, the owner can reclaim them. Possibly add a field like primary_trainer_id vs assigned_trainer_id.
PUT /trainer/planner/events/{eventId}/assign-trainer – Similar for sessions: change the trainer responsible for a session/event. Could also be covered by the generic update event endpoint if trainer_id field is allowed to change.
GET /trainer/team/clients – (Optional) For a team member, list of clients they have (delegated to them). Owner could also use this to see breakdown by trainer. Alternatively, the main clients endpoint could include team filters.
GET /trainer/team/sessions – (Optional) List sessions per team or per trainer. Could be part of the main planner endpoint with filters.
Commission handling might not need separate endpoints unless doing payouts. For now, we likely just store the rates.
Database Schema:
Teams table: id, name, owner_trainer_id, created_at. Perhaps also a subscription level if team features require a certain plan (not in scope explicitly).
TeamMembers table: id, team_id, trainer_id, role (enum or text: e.g. "owner", "coach", "assistant"), can_invite (bool), can_manage_clients (bool), can_manage_plans (bool), ... (permissions flags), commission_rate (decimal), joined_at. The owner will have full permissions implicitly.
Clients table update: If a client can be delegated, one approach is to simply change the trainer_id to the new trainer. However, to keep track that the client is still under the team, we might want to keep the team owner as well. Options: add owner_trainer_id in Clients to always record the original owning trainer (team owner), and use trainer_id as current assigned trainer. Or add a boolean on client like is_team_client and have a separate mapping. A simpler approach: when a team exists, all clients of the team members are effectively team clients, and the team owner can see them all. We can implement by queries (all clients where trainer_id in (team members)). For explicit delegation, adding owner_trainer_id is useful. Let’s assume: add owner_trainer_id to Clients – for solo trainers, owner_trainer_id = trainer_id, for team scenarios, owner_trainer_id = team owner’s id, and trainer_id = the member currently handling them (could be same as owner). This way, the team owner can query all clients where owner_trainer_id = themselves.
Events/Sessions table update: similarly, sessions may have a trainer_id field (the trainer conducting it). If a session was scheduled by owner but assigned to member, store that member’s id in trainer_id and perhaps keep created_by as owner if needed. Or have an owner_id if needed for financial tracking. At least ensure trainer_id can reference any team member.
Commission storage: On each session or client, we might store the commission applicable. For instance, a session could compute commission based on the trainer who delivered it and store an earning split. This might be too detailed for Phase 1 – likely just storing commission rates in TeamMembers and later using them in reports. If needed, a CommissionRecord table could log earnings per session per trainer, but since actual payment processing for sessions is not fully fleshed out, we skip detailed financial records now.
Invites: Possibly reuse a generic invite table or just generate tokens. If needed, a TrainerInvites table: id, team_id, email, token, role, permissions, commission_rate, invited_at, accepted (bool).
Notes on Cross-Module Integration: Team functionality affects other modules’ behaviour. In Clients module, if the trainer is part of a team, the client list should reflect clients that belong to the team. The team owner should see all clients across the team (or at least have the option to), whereas a team member might see only clients assigned to them (plus maybe those unassigned or shared if that exists). In Planner, events created by any team member or assigned to them should appear on their calendar; possibly the owner might have a view of all team events or filter by trainer. For now, assume each trainer sees their own schedule. When creating events, the owner can assign a trainer – then that event should show up on the assignee’s calendar (so the GET /events should by default return events where trainer_id = current user’s id; owners might get an option to see all or manage all events). Messaging: team members might communicate with clients they handle, but the owner might also need access. This could get complicated (multiple trainers chatting with one client). Perhaps by design, once a client is delegated, that secondary trainer becomes their point of contact. The owner might still have overview, but not actively chat unless they take the client back. This can be refined later; for now, mention that if a client’s trainer_id changes, their messaging thread should route to the new trainer. Membership Logic: It’s possible that creating a team or having team members is a Pro (paid) feature. For example, Free tier may not allow team creation. We should note that team features likely require a Pro membership. Also, commission tracking might tie into payment processing if the platform ever handles splitting payments – but that’s outside this immediate scope. Ensure removal of a team member does not orphan their clients: implement reassigning those clients to owner or another member when someone leaves. Team deletion (if owner leaves or dissolves team) should similarly handle clients (likely all revert to the owner as solo). These edge cases can be noted for completeness.
Membership Logic (Trainer Account Tiering)
Purpose: Manages the subscription tiers for trainer accounts (Free vs Pro, etc.), enforcing feature limits and handling upgrades/downgrades. Ensures that Free tier trainers have restricted access (e.g. limited number of clients and limited AI credits) while Pro tier offers full functionality. Also handles grace periods after expiration and prompting upgrades. Dependencies: Integrates with all modules to enforce limits (e.g. Clients module for client count, Nutrition/Workouts for AI usage, Team for availability, etc.). Requires integration with a Payment system for upgrading (likely subscription payments). Also uses Notifications or UI banners to inform trainers of their status. Frontend Components:
Membership Banner: If a trainer’s subscription is expired or nearing expiry, display a banner or alert on the top of the dashboard (or globally) indicating the status (e.g. “Your Pro membership has expired, you have been downgraded to Free. Upgrade to restore full access.”). Include a call-to-action button linking to the upgrade page. Similarly, if within grace period: “Your Pro plan expired 3 days ago, your account will downgrade in 4 days. Please renew to retain your features.”
Upgrade Page: A dedicated page or modal where trainers can view tier options and enter payment. Show Free vs Pro feature comparison (for example: Free – up to N clients, limited AI credits, no team; Pro – unlimited clients, AI features, team access, etc. based on the known differences). Provide monthly and annual pricing options, with annual discounted. The UI should allow selecting a plan (radio buttons or cards), then a payment method input (or redirect to a payment portal). If using an external system like Stripe Checkout, the “Upgrade” button might redirect there.
Account Settings Section: Within profile or a settings page, show current membership status (e.g. “Plan: Free” or “Plan: Pro (renews on DATE)”), and provide an “Upgrade” or “Manage Billing” button. Also list usage stats if relevant (e.g. “Clients: 5/5 (limit reached)” for free tier, “AI credits used: 3/10” etc.). This gives trainers insight into how close they are to limits.
Feature Lock/Prompts: Various UI elements across modules should check membership. For instance, if a Free user tries to add a 6th client (beyond limit), the UI should show a prompt: “Client limit reached. Upgrade to Pro for more clients.” Similarly, if an AI generation is attempted with no credits left: “AI usage limit reached. Upgrade to Pro for unlimited plan generations.” These messages should be friendly and guide the user to the upgrade flow.
Backend Endpoints:
GET /trainer/membership – Get current membership status for the trainer. Returns tier (Free/Pro), current period end date, grace_period_end (if in grace), limits (e.g. max_clients allowed, AI credits remaining if tracked, etc.). This is used by the frontend to show status and enforce UI logic.
POST /trainer/membership/upgrade – Initiate an upgrade to Pro. This might integrate with payment: possibly create a checkout session or handle payment details. If using an internal simple system, accept plan type (monthly/annual) and payment info to charge. Likely though, it will redirect to an external payment provider or use their API. In any case, upon successful payment, update the trainer’s tier to Pro and set the new expiry or renewal date.
POST /trainer/membership/cancel – If allowing cancellation, though not mentioned, but maybe manage subscription cancellation. Could mark their plan to not renew.
POST /trainer/membership/apply-coupon – (Optional) for discount codes if any, not mentioned explicitly.
Webhook endpoints (if using external payments): e.g. /webhook/payment to handle asynchronous notifications like payment success, subscription renewal, cancellation, etc. The system needs to react to these (e.g. if a subscription expires or payment fails, eventually trigger downgrade).
Scheduled Jobs: A daily job to check for accounts past grace period and auto-downgrade them. Also to grant monthly AI credits if that’s a renewing resource (or reset counters).
Database Schema:
Trainers table update: Add fields for membership: plan_type (Free/Pro), plan_expiry or next_billing_date, grace_period_until (if applicable), max_clients (could be derived from plan but maybe store for quick access), ai_credits (if using a credit count that resets periodically), last_payment_id etc. Alternatively, a separate Subscriptions table might track this.
Subscriptions/Memberships table: id, trainer_id, plan (Free/Pro), status (active, expired, grace), start_date, end_date, renewal_period (monthly/annual), payment_reference. If integrated with payment provider, store subscription ID from that service. Could also store grace_until.
Possibly a Usage table if tracking things like how many AI calls made in the current period, though if unlimited for Pro, maybe only track for free. But easier: have something like ai_credits_used_month in Trainers table that resets monthly for free tier, or ai_last_used_at to enforce cooldown.
Payments table: if handling one-time payments (for subscriptions or for event fees), a common payments table can log it. For membership, record trainer_id, amount, plan, period, transaction_id, date. This could be used for receipts or future revenue analytics.
Client Count Check: Could simply count from Clients table when needed, but sometimes storing the count or updating it on changes can be quicker. Probably unnecessary optimization at this stage.
Notes on Cross-Module Integration: Membership logic places constraints across the platform. Key integrations:
Clients Module: Impose a limit on number of active clients a Free-tier trainer can have (for example, if Free tier limit is 5 clients, the POST /trainer/clients endpoint should return an error once 5 are reached). Also possibly restrict inviting new clients beyond limit. If a Pro subscription expires and they go to Free but currently have more clients than allowed, enforce “view-only if over limit” – meaning the trainer should not be able to add new data or new sessions for the extra clients above the limit. Implementation: identify which clients are beyond the limit threshold (e.g. the 6th, 7th, etc) – one approach is to sort by join date and mark the latest ones as inactive or locked. More simply, allow viewing their info but disable adding new plans or sessions for them. We can handle this in UI (show a lock icon on those clients) and backend (check in endpoints like adding session or plan: if trainer is free and client count over limit, block if target client is one of the overflow ones or block all until they reduce count). A grace period of 7 days after expiry means within those 7 days, still behave as Pro. After that, automatically apply the restrictions.
AI Generation (Nutrition/Workouts): For Free tier, define a number of credits (e.g. X plans per month) and a cooldown (e.g. one plan per day or some interval). The backend should decrement credits and record timestamp of last use, refusing generation if out of credits or if last use is too recent (cooldown not elapsed). Pro tier can be unlimited, but maybe still enforce a reasonable rate-limit to prevent abuse (cooldown could be removed or much shorter for Pro). These rules need to be coded in the generate endpoints. Additionally, if free user tries to use after credits exhausted, the endpoint could respond with a message indicating upgrade needed.
Team Management: Possibly only Pro trainers can create a team. So the POST /trainer/team should verify membership = Pro. If a Pro subscription lapses, what happens to the team? Likely the team features get locked: perhaps they cannot invite new members or maybe the team is frozen. Possibly the team remains but maybe the secondary trainers lose access until owner upgrades again. This could be complex; at minimum, show a warning that team is not available on Free. Could automatically suspend the team (team members might not be able to login or see clients?). For simplicity, we might enforce that if owner is downgraded, they must upgrade to continue team operations – potentially lock new actions and inform them. This could be handled by checking membership status on relevant endpoints (like creating sessions for team or accessing team info).
Planner/Calendar: Possibly limit number of active events or group sessions on Free tier (not given in prompt, but some products do). Since not specified, we skip that. But if such a limit exists, enforce similarly.
Export to PDF: This might be a Pro-only feature (often advanced features like exporting reports might be premium). The prompt doesn’t say explicitly, but we can hint that maybe Free tier doesn’t have PDF export or it’s watermarked or limited. It says membership logic to include showing upgrade prompt when expired, etc. If not sure, we won’t assert it, but could note as a consideration.
UI/UX: We need to ensure everywhere that if the account is expired and out of grace, actions that are not allowed are either hidden or prompt upgrade. E.g., add client button disabled with tooltip “Upgrade required”, attempt to generate AI plan shows a modal to upgrade, team page perhaps read-only or invites disabled, etc.
Background task: at the end of grace period, auto-downgrade the trainer. This means flip their plan to Free and likely store which features to lock. Possibly send an email or in-app notification about the downgrade.
Upgrade Flow: Once payment is done and membership active, re-enable all features and maybe unlock any locked clients (they should be able to interact with them again). If any data was hidden or read-only, make it active. So transitions must be smooth.
This module essentially is overarching; testing and ensuring it doesn’t break usage flow is critical.
Export to PDF
Purpose: Allows trainers to export a client’s progress and metrics into a PDF report. This report can be used to show clients their progress or for trainers to keep records, and it is branded with the trainer’s details (logo, name, contact info). Dependencies: Pulls data from Clients (personal info and metrics), Check-In System (progress metrics, graphs, photos), possibly Workouts/Nutrition (to include an overview of plans or compliance, if desired) – though primarily it seems to focus on progress metrics. Uses Trainer Profile for branding (logo and name). May rely on a server-side PDF generation library. Frontend Components:
Export Modal/Form: Triggered likely from a client’s profile page (e.g. a “Export Report” button). In the modal, allow the trainer to configure the export if needed: select date range (e.g. last 3 months, or all time), choose which data to include (check-ins, weight chart, perhaps before/after photos if available). Could also allow uploading or selecting a logo if not already in profile (but since profile has logo, reuse that). There might be a template preview or at least a description of what will be in the report.
Export Generation Feedback: Once export is initiated, show a loading indicator and then a success message with a link to download the PDF (or auto-download). If generation is quick, it might just download after a moment; if it’s longer or done async, perhaps notify when ready. But likely it’s sync for simplicity if data isn’t huge.
PDF Template (Design): Not a UI component per se, but we need to design a clear PDF layout. Typically: Cover page or header with trainer’s logo, name, contact; then client name and perhaps a summary of their stats; followed by sections like “Progress Overview” – listing weight changes, measurement changes, etc., maybe with a small chart or table; possibly a section for “Check-In History” or notable metrics; if including photos, maybe a page with before/after images side by side with dates. The template is fixed format per spec, meaning the layout is pre-defined and not highly dynamic beyond filling in data. The AI agent will implement this layout in code (likely using an HTML-to-PDF library or PDF generation library).
Backend Endpoints:
POST /trainer/clients/{clientId}/export – Generate a PDF report for the given client. Input could include options like date range or sections to include (if the UI provides those). On server side, gather the data: client profile info, check-in records (within range), maybe latest body metrics, possibly list active plans or something if desired. Then generate a PDF (e.g. using a library) with that data. Save the PDF to a temporary location or memory and return it (as file download). Alternatively, generate and email it to the trainer if direct download is an issue. But simplest is immediate download.
Possibly GET /trainer/clients/{clientId}/export?requestId=... if generation is async, but likely not needed if done synchronously for now.
(No dedicated DB changes for this feature aside from ensuring needed data is available via other tables.)
Database Schema:
No new tables specifically for exporting. However, ensure the Trainer profile has fields for logo URL and contact info (phone, email) to include in the report. If such fields don’t exist, we might have to add, e.g., logo_url in Trainers table, and maybe business_name or use trainer’s name, and a contact field if needed separate from their login email.
Ensure the data to be exported (metrics, check-ins, etc.) is accessible. If we want to include charts, the data points (like weight over time) come from CheckIns or a metrics table. The AI agent can generate a chart (like using a small chart image) or simply list numbers. Given a fixed format, perhaps no actual graph generation is needed initially, just tabulated data.
Notes on Cross-Module Integration: The export feature is read-only in nature but draws from multiple modules: Clients (basic info like name, start date, goals), Check-In System (most recent and historical measurements, which are the core of progress tracking), and possibly Nutrition/Workouts (the plan names or summary could be included if desired, e.g. “Current Plan: 12-Week Bulk Program”). If the trainer uploaded progress photos via Check-Ins, including a before/after photo can greatly enhance the report, so integrate with the stored check-in photos (e.g. take the first and last images in the period or allow selecting two dates for comparison). Branding integration means using the trainer’s profile data. Ensure that any image (like logo or photos) included in the PDF is fetched and embedded correctly. Also consider if Free tier users have access: if not, and if it’s meant to encourage upgrade, attempting to use it could prompt upgrade. But the prompt did not explicitly say it’s limited, so perhaps it’s available to all. If making it Pro-only, the endpoint or UI should check membership and respond accordingly. After generation, the system might log an event (for example, could add a timeline entry “Exported progress report on [date]” for internal tracking, though not necessary).
Timezone Support
Purpose: Ensures that all date/time related features (particularly scheduling in Planner and check-in reminders) respect user timezones. The trainer’s default timezone is used for their scheduling interface, but clients should see session times in their own local time. All backend logic stores times in a standard format to avoid confusion across zones. Dependencies: Affects Planner (sessions/events), Check-In System (reminder scheduling), Messaging (timestamps display), and any place where time is shown or input. It relies on having timezone information for users (trainer and clients). Also requires any scheduling to convert appropriately when sending notifications or displaying in UI. Frontend Components:
Timezone Settings: In Trainer Profile (and similarly for clients in their profile, though that’s phase 2), include a field to set/select timezone. Possibly use a dropdown of region names (Europe/London, etc.) or auto-detect on signup. This ensures the system knows each user’s timezone.
Calendar Display: The Planner calendar should clearly indicate the timezone being shown. If the trainer’s own timezone is used for their view (which it should), and they create sessions at say 10:00, it’s 10:00 in their timezone. If they invite a client in another timezone, the invite that the client sees should be converted. For now, on trainer side, just show times in trainer’s zone, but perhaps display a note like “(Client local: X)” if they select a client and that client is in a different timezone, just to avoid confusion (could be an advanced detail).
Date-Time Inputs: All UI where date and time are entered (session scheduling, recurring check-in setup) should handle timezone gracefully. Typically, the frontend will use local (trainer’s) time to create an event, send it to backend as an ISO timestamp with offset. The backend stores in UTC. Then when retrieving for display, convert to trainer’s zone for their view. For client’s view (phase 2), convert to client’s zone.
Notification Content: When sending emails or messages about upcoming sessions, include the time in the recipient’s local time. e.g. if a UK trainer schedules a session at 10:00 UK time with a client in New York, the email to the client might say “Session at 5:00 AM (your local time) / 10:00 AM UK time”. Handling this might require formatting on the server or separate communication for different users.
Backend Considerations:
All timestamps should be stored in UTC in the database, as a rule
medium.com
. The backend should not assume a single timezone; it should always convert incoming times to UTC for storage, and convert outgoing times to the user’s timezone for display or notifications
medium.com
.
User Timezone Data: Ensure the Trainers table and Clients table have a timezone field (probably store as tz database name like “Europe/London”, not just offset, to handle DST). This is filled at signup or by profile settings.
Scheduling Logic: When creating events (sessions) via Planner, the input from trainer (in their zone) should be converted to UTC before saving. Store maybe the timezone as well in an ancillary field if needed (e.g. store both UTC time and original timezone of creation if you want to keep reference, but generally storing only UTC is fine as long as you know whose perspective to show in). For recurring check-ins, if a trainer sets “every Monday at 9am” for a client, we should interpret that likely in the client’s timezone (since the client will be the one receiving it at 9am their time). So, when scheduling a reminder, use the client’s timezone offset to compute the UTC trigger time. This might involve storing the schedule time in client local terms but converting to UTC for actual scheduling. Possibly simpler: store an absolute next due datetime in UTC (computed from client’s zone). Each time you compute the next one, do it in client’s zone then convert.
Backend Endpoints: No specific endpoints just for timezone, but every relevant endpoint should take timezone into account. For instance, GET /trainer/planner/events might accept a timezone param or default to trainer’s; it could convert all times to that zone before returning (or the frontend can handle conversion if it knows the timezone of user). Probably easiest: backend returns UTC timestamps and the frontend (which knows the user’s tz) converts. But for convenience, the agent could implement a middleware to attach timezone info.
Testing: We should test events with trainer and client in different zones to ensure invites and reminders align correctly.
Database Schema:
Trainers.timezone (string): e.g. “Europe/London”.
Clients.timezone (string): e.g. “America/New_York”.
Possibly an Events.timezone if we wanted to store the event’s base timezone, but unnecessary if using UTC. If a trainer travels and changes their timezone, events they created remain at the correct absolute time; their display might shift if they view in new zone, which is expected. So better not to fix events to a zone, keep in UTC.
CheckInSchedule might not need a timezone if we always assume it’s based on client’s timezone (just use client.timezone at runtime to compute reminders). If clients might travel/change tz, could get tricky, but typically they keep their profile tz updated if they move permanently.
Notes on Cross-Module Integration: Timezone support underpins the Planner and Check-In modules primarily. For Planner: ensure that when an event invite is sent to a client, it is communicated in the client’s local time (the system can look up client’s timezone and format the time accordingly in the message or email, e.g. using something like Intl.DateTimeFormat with the target zone). For Check-Ins: if a trainer sets a schedule for a client, presumably the intention is that the client gets the reminder at a convenient local time (like Monday morning their time). So align the scheduling to client zone. Also, any date displayed in the Timeline or Messaging for events or messages should ideally appear in the viewer’s local time. On the trainer side, that means their timeline shows times in their zone (which is fine if everything they did was in their zone originally). On a client app, the timeline might show when a session occurred in their local time. The system’s consistent use of UTC storage and local conversion will handle these scenarios. Document and be mindful of daylight savings changes – using tz names handles DST automatically when converting with proper libraries. This robust timezone handling will improve user experience across regions.